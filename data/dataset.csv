Titel;Geltungsbereich;Kategorie;Beschreibung
single use files;Frontend, Backend;Projektstruktur;exportierte Klassen, Interfaces, Enumerationen, Types werden immer in einer separaten Datei abgelegt.
Ablage von öffentlichen Models/DTOs;Frontend, Backend;Projektstruktur;"Öffentliche/exportierte Models sind immer in der Nähe ihrer Fachlichkeit abzulegen. Das Model sollte sich in der gleichen Ordnerstruktur des dazugehörigen Moduls befinden. Models sollten immer in einem eigenen Unterordner ""models"" abgelegt werden."
Ablage von privaten Models/DTOs;Frontend, Backend;Projektstruktur;Wird ein Model nur innerhalb einer Datei benötigt, so darf dieses Model nicht exportiert werden und kann dann privat in dieser Datei abgelegt werden.
Ablage von Services;Frontend, Backend;Projektstruktur;"Services sind immer in der Nähe ihrer Fachlichkeit/Moduls abzulegen. Services sind immer in einem separaten Unterordner ""services"" abzulegen."
Zweckbindung von Services;Frontend, Backend;CodeQuality;Services sollten immer nur Funktionalitäten enthalten, die ihrem eigenen Zweck dienen. Utilities oder andere Fachlichkeiten sind in entsprechende andere Strukturen auszulagern.
Call it in ngOnInit;Frontend;Performance, BestPractice;Reservieren Sie den Konstruktor für eine minimale Initialisierung, z. B. für die Verknüpfung von Konstruktorparametern mit Eigenschaften. Der Konstruktor sollte darüber hinaus nichts tun. Er sollte auf keinen Fall eine Funktion aufrufen, die HTTP-Anfragen an einen entfernten Server stellt, wie es ein echter Datendienst tun würde. Quelle: https://angular.io/guide/lazy-loading-ngmodules
Observables zerstören;Frontend, Backend;Performance;Observables sollten bei Aufrufen von subscribe immer zerstört werden. In Angular kann hierfür der Operator takeUntilDestroyed genutzt werden. Andernfalls kann der Operator takeUntil verwendet werden. Dies gilt auch für selbst-Abschließende Observables wie solche, die mittels des HttpClients erzeugt wurden.
Quellcode-Dokumentation - Wo?;Frontend, Backend;Wartbarkeit;Alle Öffentlichen/exportierten Klassen, Interfaces, Enumerationen und Types müssen durch einen jsdocs-Kommentar dokumentiert werden. Auch deren öffentlichen Member müssen dokumentiert werden. Eine Ausnahme bildet die constructor -Funktion, hier muss nicht zwingend dokumentiert werden. Komplexe interne/private Methoden, sollten dennoch dokumentiert werden. Darüber hinaus ist Notwendigkeit für weitere Dokumentationen dem Entwickler oder Reviewer überlassen.
Fehler dürfen nicht verschluckt werden;Frontend, Backend;ErrorHandling, Wartbarkeit, Useability;Abgefangene Fehler sollten immer weitergereicht werden und sollten nicht verworfen werden.Korrekte Weitergaben wären: 1. Weitergabe an globales Error Handling 2. Übergabe in den cause eines neuen Errors 3. Übergabe an einen Logger/Notifier 4. Anzeige im UI
Quellcode-Sprache;Frontend, Backend;Wartbarkeit;Die Sprache im Quellcode und der Quellcode-Dokumentation ist Englisch. Fachwörter dürfen aber in deutsch belassen werden, sofern dies die Verständlichkeit fördert.
InMemory Caching von Http-Anfragen;Frontend, Backend;BestPractice;RxJs-Observables können mit dem shareReplay - Opertator gecached werden, wichtig ist hierbei, das die Observable-Instanz wiederverwendet wird und nicht jedes Mal neu erzeugt wird.
Dauerhaftes Caching von Http-Anfragen;Frontend;BestPractice;Zum dauerhaften Cachen von Daten aus einer Http-Anfrage, ist die Verwendung des LocalStorage zu empfehlen, nur bei komplexeren Datenstrukturen, welche lokal intensiv ausgewertet werden, könnte auch die Verwendung der IndexDB in Frage kommen.
ShareReplay Limitieren;Frontend, Backend;BestPractice;"der RxJs-Operator shareReplay sollte immer mit einem Konfigurationswert ""1"" verwendet werden, da dieser ansonsten auch immer ältere Werte beim subscribe wiederholt."
Quellcode-Formatierung;Frontend, Backend;CodeQuality, Wartbarkeit;Sämtlicher Quellcode muss immer allen Regeln von Prettier entsprechen. Nur in HTML-Dateien dürfen 150 Zeichen pro Zeile stehen.
native private Properties;Frontend, Backend;CodeQuality, Security;JavaScript-Private-Properties (#-Präfix) wird bei uns nicht verwendet
Zusammensetzen von URLs;Frontend, Backend;BestPractice;"Urls sollten mithilfe des npm-Paketes url-join  zusammengesetzt werden, so muss man sich keine Gedanken um führende, nachfolgende oder doppelte ""Slashes"" machen."
UI mit WebComponents;Frontend;Useability, CorporateDesign;Alle Oberflächen sind mit den WebComponents der Musterfirma (@Musterfirma/xx-commons-ui) umzusetzen
custom CSS;Frontend;Useability, CorporateDesign, Wartbarkeit;Eigenes CSS ist generell zu vermeiden, ist es dennoch notwendig, so ist dies als Ausnahme in der CSS-Definition mittels Kommentar zu dokumentieren → Ursache muss ersichtlich gemacht werden. CSS wird allgemein durch die WebComponents gesteuert und bereitgestellt. Diese Regel betrifft eigene CSS-Dateien, Style-Tags und Style-Attribute.
LazyLoading;Frontend;Performance;Große Projekte sind grundsätzlich in mehrere Module aufzuteilen, welche dann über das Routing lazy geloaded werden können. Quelle: https://angular.io/guide/lazy-loading-ngmodules
Allgemeine Fehlerbehandlung;Frontend;Wartbarkeit, Useability, ErrorHandling;Alle Frontend-Projekte müssen die Dependency @musterfirma/cc-errors einbinden und damit das globale ErrorHandling der Musterfirma aktivieren. Abweichungen durch Ableitungen vom GlobalErrorHandler sind zulässig.
Hinzufügen von CC-Errors;Frontend;BestPractice;Komandozeilenbefehl: ng add @Musterfirma/cc-errors 
Redirects in Guards;Frontend;BestPractice;Guards sollten keine Redirects oder derartige Navigationen ausführen. Besser ist es Zugriffe mittels canMatch zu prüfen und Redirects über das Routing abzubilden
TrackBy;Frontend;Performance;Alle Verwendungen von *ngFor müssen mit einem trackBy ausgesattet werden. Werden FormularElemente (FormControl, FormArray oder FormGroup) iteriert, so kann der Helper idFormTrackBy aus der Dependency @Musterfirma/cc-forms verwendet werden.
EnumValues;Frontend, Backend;Wartbarkeit, CodeQuality;Enummerationen sind immer mit einem eindeutigen String-Value anzugeben, der dem EnumKey entspricht
Typescript-Dateinamen;Frontend, Backend;Projektstruktur;Alle Typescript-Dateien müssen dem folgenden Schema entsprechen: [name].[typ].ts Name: Name der Datei in Kebab-Case Typ: Typ des Dateiinhaltes (z.B. service, component, controller usw.) in Kebab-Case
Dependency-Injection;Frontend;BestPractice;Bevorzugt werden Abhängigkeiten über den Konstruktor injiziert. Dem Entwickler ist aber freigestellt inject() zu verwenden.
Required-Properties in Klassen;Frontend, Backend;CodeQuality;Die Verwendung des ! -Postfixes an Properties ist generell untersagt. Ursache: Der Postfix umgeht Typisierungsprobleme, welche besser über eine saubere Typisierung gelöst werden sollte. Beispiel @Input() in Angular: Inputwerte sind nie sicher gesetzt, auch wenn Angular sich um deren Bereitstellung kümmert oder dieser am Decorator als required markiert sind. Inputs werden erst zu einem späteren Lifecycle gesetzt, zwischen der Ausführung des Konstruktors und dem ersten Aufruf von ngOnChanges sind diese Werte ggf. undefined . Als weiteres Problem sind hier programmatisch erzeugte Komponenten (mittels ViewContainerRef) zu nennen, bei dieser Art der Erzeugung greifen die Angular-Automatismen nicht. Sind Eingabewerte für eine Angular-Komponente zwingend erforderlich, so sollte der Input-Parameter mittels required  in dem @Input Decorator markiert werden.
required Inputs;Frontend;BestPractice;Achtung: Dies stellt nicht sicher, dass der Wert auch wirklich gesetzt ist. Die Verwendung des ! Postfixes ist somit nicht zulässig.
Wiederbeleben eines Subjects/Observables nach Fehlern;Frontend, Backend;BestPractice;Der RxJs-Operator retry kann verwendet werden um ein geschlossenes Subject/Observable wiederzubeleben, falls das Observable z.B. durch einen Error geschlossen wurde. Dadurch reagiert das Subject nicht mehr, wenn es getriggert wird.
Verwendung von Pipes;Frontend;BestPractice, Performance;Pipes sollten lediglich zur Transformation von Daten zu Strings verwendetet werden. Eine Verwendung zur Modifikation von komplexen Objekten sollte vermieden werden, da dies zu Performance-Problemen führen kann.
Angular Version;Frontend;Security, Performance;Es wird angestrebt immer die zweitneuste Version (major) von Angular einzusetzen. Federführend ist jedoch das Projekt @Musterfirma/cc-app-template
Build-Plattform;Frontend, Backend;CI/CD;Abgesehen von lokalen Entwicklungsbuilds werden Projekte ausschließlich auf dem internen Bamboo-Build-Server gebaut https://bamboo.musterfirma.net/
Releases;Frontend, Backend;CI/CD;Releases werden durch das Setzen und Pushen eines Git-Tags von dem master Branch getriggert
Branch-Namen;Frontend, Backend;CI/CD;Zulässige Branchnamen bzw. Namenspattern sind: master, develop, feature/*, hotfix/*, bugfix/*, release/*,
Änderungen auf dem Master-Branch;Frontend, Backend;CI/CD;Änderungen auf dem master -Branch sind nur im Rahmen eines Releases zulässig und begrenzen sich lediglich auf das Anpassen der Version in der package.json sowie der Pflege des Release-Datums in der CHANGELOG.md
Änderungen auf dem Develop-Branch;Frontend, Backend;CI/CD;Änderungen auf dem develop-Branch sind nur durch das Stellen von Pull-Requests im Bitbucket zulässig
Review-Pflicht;Frontend, Backend;CI/CD;Alle Änderungen am Quellcode müssen vor der Übernahme in den develop-Branch durch mindestens einen internen Entwickler gereviewt werden. Dieser Reviewer darf nicht selbst der Author der Änderungen sein. Zusätzliche, auch externe Entwickler, sind als Reviewer zulässig.
Erfolgreicher Build bei Review;Frontend, Backend;CI/CD;Reviews setzen voraus, dass der Build erfolgreich durchgelaufen ist, wodurch sichergestellt wird, dass: das Projekt buildfähig ist, alle Tests erfolgreich waren, alle Linting-Regeln erfüllt sind, alle Formatierungsregeln erfüllt sind
IDE;Frontend, Backend;BestPractice;Dem Entwickler ist die Wahl der IDE freigestellt, solange sichergestellt ist, dass er damit effizient in unserer Umgebung und mit unseren Tools und Technologien arbeiten kann. Bevorzugt wird die Verwendung der IntelliJ, Offiziell unterstützt werden IntelliJ und VSCode - für andere IDEs ist der Entwickler selbst zuständig.
Klassennamen;Frontend, Backend;CodeQuality;Klassen werden in PascalCase geschrieben und bilden sich aus dem zugehörigen Dateinamen. Der Name einer Klasse ist immer möglichst sprechend zu wählen, sodass der Sinn und Zweck der Klasse möglichst gut erkennbar wird. Variablen werden immer in CamelCase geschrieben. Der Name soll den Inhalt und Zweck der Variable möglichst kurz und verständlich wiedergeben. Notationen wie die Ungarische Notation, bei denen der Datentyp im Variablennamen verbaut wird, sind nicht zulässig.
Variablennamen;Frontend, Backend;CodeQuality;Das Markieren von privaten Variablen durch einen führenden '_' (Unterstrich) ist nicht zulässig.
Nicht-Standard-Dependencies;Frontend, Backend;Security, Wartbarkeit;Dependencies, welche nicht durch die zur Verfügung gestellten internen Libraries verwaltet werden, sind nur nach Absprache mit der Entwicklungsleitung zur Verwendung freigegeben. Diese zusätzlichen Dependencies müssen zwingend in der README.md inklusive einer Begründung dokumentiert werden.
Oberflächentest happy-Path;Frontend;CI/CD, Wartbarkeit;Alle Applikationen müssen mindestens einen Oberflächentest aufweisen, welcher den happy-Path der Anwendung abdeckt. Zusätzliche Tests sind zulässig.
Oberflächentest Framework;Frontend;CI/CD, Wartbarkeit;Oberflächentests werden mit playwright und der Dependency @Musterfirma/cc-e2e-playwright umgesetzt
Dokumentation der WebComponents;Frontend;CorporateDesign, Infrastruktur;Die Dokumentation der WebComponents ist unter der URL https://test-kube.musterfirma.net/general/c-docs-app/ verfügbar. Dort wird immer die neuste stable-Version angezeigt. Die Dokumentation für den neusten Snapshot-Build der WebComponents findet sich hier: https://dev-kube.musterfirma.net/general/c-docs-app/
Ticketsystem;Frontend, Backend;Projektmanagement, Infrastruktur;Projekte und die zugehörigen Sprints, Tasks etc. werden ausschließlich im internen Jira verwaltet: https://jira.musterfirma.net/
NPM-Repository;Frontend, Backend;Security, Infrastruktur;Alle NPM-Dependencies werden über den Nexus https://nexus-prod.musterfirma.net/ bezogen
Publishing von Npm-Packages;Frontend, Backend;Infrastruktur;Releases werden immer im Repository https://nexus-prod.musterfirma.net/repository/npm-releases/ veröffentlicht. Snapshots müssen immer in das Repository https://nexus-prod.musterfirma.net/repository/npm-snapshots/
Code-Repository;Frontend, Backend;Infrastruktur;Alle Quellcodes sind im git-Repository von Bitbucket abzulegen https://bitbucket.musterfirma.net/
Sortierung von Imports;Frontend, Backend;BestPractice;Die Reihenfolge der Imports in einer Typescript-Datei wird nicht vorgeschrieben und ist frei wählbar. Der Einsatz von Tools zur automatischen Sortierung von Imports ist untersagt, da dies nur unnötige Änderungen verursacht.
Zweckbindung eines Branches;Frontend, Backend;BestPractice;Branches zur Code-Änderung (alle außer develop, master und release) dürfen keine Änderungen enthalten, die nicht explizit dem Zweck des Branches dienen. Das Umsetzen weiterer Features oder Fixes muss in einem eigenen Branch erfolgen. Dies erleichtert die Zusammenarbeit der Entwickler und macht die Reviews deutlich übersichtlicher.
README.md;Frontend, Backend;Dokumentation, Wartbarkeit;"Jedes Projekt muss in seinem Wurzelverzeichnis eine README.md enthalten. Diese Datei muss Aufschluss über die folgenden Dinge geben: Sinn und Zweck des Projektes, Anleitung zum Herstellen der Entwicklungsfähigkeit / Getting Started, Dokumentation der involvierten Umsysteme
Anleitung zum Starten der Anwendung, Anleitung zum Ausführen der Tests, Beschreibung der Projektstruktur, Dokumentation der Konfigurationsparameter, Auflistung von verwendeten Nicht-Standard-Dependencies, weitere Besonderheiten (wenn vorhanden), Dokumentation des Datenbankschemas (wenn vorhanden)"
Changelog;Frontend, Backend;Dokumentation;Jede Änderung im Quellcode muss in Form eines Changelog-Eintrags in der CHANGELOG.md in der passenden Version dokumentiert werden. Zielgruppe des Changelogs sind andere Entwickler. Der Aufbau des Changelogs orientiert sich an https://keepachangelog.com/, Das Changelog selbst liegt im Wurzelverzeichnis des Projektes und trägt den Namen CHANGELOG.md
Backend-DTO-Classes;Backend;CodeQuality;Alle DTOs sind im Backend als Klassen umzusetzen. Dies ist notwendig, damit Swagger alle Informationen zur Laufzeit auslesen kann.
Klassen immer instanziieren;Frontend, Backend;CodeQuality;Werden Objekte mittels Klassen typisiert (z.B. DTOs im Backend), so sind diese auch als Instanzen dieser Klassen zu erzeugen. Im Backend kann dies z.B. mithilfe des clazz-transformer packages erfolgen. Hintergrund: Dies vermeidet Verwirrungen, weshalb z.B. Instanceof-Checks nicht funktionieren, obwohl der Entwickler glaubt, eine Klasseninstanz in der Hand zu halten.
Keine Methoden an Models und DTOs;Frontend, Backend;CodeQuality;Models oder DTOs können als Klassen typisiert werden, dürfen aber keine Methoden haben. Begründung: Diese Strukturen sollen so einfach wie nur möglich gehalten werden und keine Logik beinhalten.
keine komplexen Templates;Frontend;CodeQuality, Performance;Angular-Templates sollten keine komplexen Logiken/Berechnungen enthalten. Mantra: Ein Designer sollte in der Lage sein, ein Template zu lesen und zu erstellen.
keine Methoden in Property Bindings;Frontend;Performance;Für das Property Binding dürfen keine Methoden verwendet werden, nur direkte Ausdrücke oder Template-Variablen.
Vermeiden von Mehrfachabfragen durch Async-Pipe;Frontend;Performance;Die async-Pipe sollte bewusst verwendet werden. Bei Verwendung mit HTTP-Requests muss beachtet werden, dass Requests nicht mehrfach ausgelöst und ans Backend gesendet werden (geeignete Caching-Strategie verwenden).
Observable-Naming;Frontend, Backend;BestPractice;Zur Besserungen Identifizierung eines Observables im Quellcode wird entsprechenden Variablen- und Methodennamen (die Observables zurück liefern) ein Dollarzeichen ($) angehängt
ReactiveForms;Frontend;BestPractice;Die Entwicklung erfolgt immer mittels ReactiveForms (keine TemplateDriven Forms). Standardwerte und Validatoren werden demnach im Code am FormControl bzw. einer FormGroup definiert und nicht im HTML. Der FormBuilder kann zum Aufbau der Formulare verwendet werden.
Typed ReactiveForms;Frontend;CodeQuality;ReactiveForms sind immer zu typisieren.
Anzeige von Formularfeldfehlern;Frontend;BestPractice;Für die Anzeige von Validierungsfehlern im Template muss immer das errors-Objekt des Controls genutzt werden und entsprechend im error-Slots an der jeweiligen Input-Webcomponent befüllt werden. Desweiteren sollten bei bestimmten Validatoren (z.B. min-Validator) die mit dem Fehler gelieferten Zusatzinformationen genutzt werden.
Label für Required-Felder;Frontend;CorporateDesign;"Bei Pflichtfeldern (""required"") muss das Label immer mit einem durch ein Leerzeichen getrenntes Sternchen (*) enden."
Ausrichtung von Buttons;Frontend;BestPractice;Die Komponente <xx-button-group> ist DEPRECATED und darf nicht mehr genutzt werden. Für die Anordnung und Ausrichtung von Buttons sollten entsprechende Flex-Klassen (z.B. xx-flex-end) genutzt werden oder - falls dies aus bestimmten Gründen nicht geht - in Ausnahmefällen das Grid-System.
Tab-Reihenfolge bei Buttons;Frontend;Useablitity;Werden zwei oder mehrere Buttons gruppiert dargestellt, so muss der Primärbutton immer zuerst den Fokus erhalten. Dies kann durch die Reihenfolge im DOM erreicht werden. Mit der Klasse `xx-flex-row-reverse` kann der Primärbutton dann trotzdem immer noch visuell hinter dem Sekundärbutton stehen.
Optionale Methodenparameter;Frontend;CodeQuality;Optionale Parameter sollten immer durch Nutzung des Fragezeichen-Operators (?) anstatt durch undefined markiert werden
Fail Fast;Frontend, Backend;CodeQuality, Wartbarkeit;Fehler sollten frühzeitig geprüft und erkannt werden. Die Fehlerbehandlung oder ein Abbruch sollte sofort erfolgen.
Switches immer mit default-case;Frontend, Backend;CodeQuality;Switches müssen immer einen default-case besitzen, welcher ggf. einen Fehler wirft, sollte dieser Fall nicht erwartet sein.
Iteration über Enums in Templates;Frontend;BestPractice;Um über Enumerationen iterieren zu können, muss das Enum dem Template bereitgestellt werden und kann dann mittels der keyvalue Pipe ausgelesen werden.
FormControl Disabled-State;Frontend;CodeQuality;Der Disabled-State eines Formularfeldes muss immer über die disable/enable-Methoden am FormControl oder dessen übergeordneten FormArrays/FormGroups gemanaged werden